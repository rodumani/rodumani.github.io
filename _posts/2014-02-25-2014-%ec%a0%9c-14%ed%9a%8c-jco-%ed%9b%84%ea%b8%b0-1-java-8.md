---
title: '2014 제 14회 JCO 후기 &#8211; 1. Java 8'
author: Rodumani
layout: post
permalink: /2014/02/2014-%ec%a0%9c-14%ed%9a%8c-jco-%ed%9b%84%ea%b8%b0-1-java-8/
categories:
  - Development
  - Java
---
2014년 제 14회 JCO가 2014.2.22에 세종대학교 컨벤션센터에서 있었습니다.

2013년 제 13회 JCO에 이어서 2번째 참석한 JCO였는데요, 작년 JCO는 전체적으로 모두 하둡에 치우쳐 있었다면 올해 JCO에서는 하둡에 관한 이야기는 없었습니다.

<div id="attachment_219" style="width: 1228px" class="wp-caption aligncenter">
  <a href="http://rodumani.kr/wp-content/uploads/2014/02/스크린샷-2014-02-23-오후-12.09.241.png"><img class="size-full wp-image-219" alt="" src="http://rodumani.kr/wp-content/uploads/2014/02/스크린샷-2014-02-23-오후-12.09.241.png" width="1218" height="1266" /></a>
  
  <p class="wp-caption-text">
    2014 JCO 행사 구성
  </p>
</div>

첫 번째로 A Track 의 2번째 세션이었던 &#8220;Java 8 and Beyond&#8221;에 대해 정리해 보고자 합니다.

현재 배포되어 있는 Java 7 는 2011년 7월에 배포되었습니다. Java7u51 까지 릴리즈 되어 있지만 여전히 개발자들이 가장 많이 쓰는 Java 는 Java6로 보입니다. 실제 발표현장에서도 Java 7을 쓰는 사람을 물어보았을 때 생각보다 적은 사람들이 Java 7을 쓴다고 밝혔습니다. (그럼에도 불구하고 이창재 수석 컨설턴트께서는 생각보다 많은 사람이 쓴다고 했습니다)  
Java 6가 2006년 12월에 배포되고 나서 그동안 2년주기로 업데이트 되던 Java가 5년만에 업데이트 되었지만 Java 7 은 개발자들에게 큰 매력이 크게 없었나 봅니다.

[Java 8의 Issue Tracker][1]를 참조하면 남은 Issue는 3개, Due는 2014-03-17 입니다. 남아있는 이슈가 JDK8의 핵심기능상의 문제가 아닌, 문서화 및 기타 도구의 문제로 일정상에 차질이 없다면 3주뒤면 Java 8을 정식으로 만나볼 수 있을 것으로 보입니다.

# Java 8의 새로운 특징

* * *1.Interface 업데이트

  
2.JSR 335: Lambda Expression  
3.Stream API  
4.JSR 310: Time and Date API 업데이트  
5.Type Annotation  
6.JDK 통합. Hotspot + JRockit  
7.Project Nashorn : JS on JVM</p> 

## 1. Interface 업데이트

Java 8에서 Interface의 업데이트가 있습니다. 조금 이따 살펴볼 JSR 335: Lambda Expression의 업데이트로 인해서 추가된 @FunctionalInterface Annotation이 추가되었고, Interface에서 static method Implementation이 지원됩니다.  
추가적으로 default method가 생겼습니다. default method는 Interface의 Abstract Method들에 대한 기본기능을 지정합니다.  
예를 들어, Java 7에서 이런 Interface는 있을 수 없습니다.

<pre class="lang:java decode:true " >// Java 7
public interface TestInterface {
	 public void action(){
		 System.out.println("Test");
	 } /* Error : Abstract methods do not specify a body */
}
</pre>

하지만 Java 8 에서부터는 default 지시자를 이용하여 Interface의 기본 기능을 정의할 수 있습니다. 

<pre class="lang:java decode:true " >// Java 8
public interface TestInterface {
	 default public void action(){
		 System.out.println("Test");
	 }
}</pre>

Interface의 default method에 관한 자세한 사항은 [이곳][2]을 참조하시면 좋을 것 같습니다. 

두 번째로 @FunctionalInterface Annotation이 추가되었습니다.  
@FunctionalInterface란, 실제로 구현해야하는 abstract function이 1개만 있는 Interface, 대표적으로 Runnable, ActionListener, Comparator 를 말합니다.

Runnable을 예시로 보죠. 

<pre class="lang:java decode:true " title="Runnable.java" >(중략)
public
interface Runnable {
    /**
     * When an object implementing interface &lt;code&gt;Runnable&lt;/code&gt; is used
     * to create a thread, starting the thread causes the object's
     * &lt;code&gt;run&lt;/code&gt; method to be called in that separately executing
     * thread.
     * &lt;p&gt;
     * The general contract of the method &lt;code&gt;run&lt;/code&gt; is that it may
     * take any action whatsoever.
     *
     * @see     java.lang.Thread#run()
     */
    public abstract void run();
}
</pre>

이게 끝입니다. 하지만 현재로서는 Runnable을 이용하여 쓰레드를 생성할 때 다음과 같이 작성해야합니다. 

<pre class="lang:java decode:true " >public static void main(String[] args) {
	Thread t = new Thread(new Runnable(){
		@Override
		public void run() {
			System.out.println("test");
		}
	});
	t.start();
}
</pre>

우리는 당연히 Runnable을 implements 한다는 것은 run()을 구현하려는 것이다는 걸 알고 있습니다. Comparator를 구현하면 compare를 구현하는 것이죠. 굳이 이름을 적어가며 Override할 필요가 없습니다. 구현되어 있는 기능은 무조건 단 하나의 Abstract Method를 위한 것이니까요. 그래서 Lambda Expression을 @FunctionalInterface의 인자로 전달하면 자동으로 하나 존재하는 Interface의 Abstract Method로 생각하여 객체화 해줍니다.

Java 8에서 Lambda를 이용하여 다음과 같이 할 수 있습니다. 

<pre class="lang:java decode:true " >// Java 8
public static void main(String[] args) {
	Thread t = new Thread(() -&gt; {
			System.out.println("test");
		});
	t.start();
}</pre>

## 2. JSR 335: Lambda Expression

Java 8의 가장 핵심 이슈, Lambda Expression 입니다. C++, C#, Objective-C, Python, Ruby와 같은 Major 언어들이 모두 지원하는 반면 (단 C++은 C++11), Java는 이제야 지원이 추가되었습니다. Lambda가 상당히 편리한 점이 많으므로 Java 8의 Lambda 도입은 환영할만한 일입니다. 

내부적으로는 JDK7에서 추가된 invokedynamic을 활용하고, Lambda의 실체는 FunctionalInterface의 Instance 입니다.

그렇다면 Java Lambda는 어떤 모습일까요?  
이미 앞서 1번에서 보신 분들도 있겠지만 Java 8의 Lambda는 

(type param1, type param2, &#8230; ) -> { //expression }

이런 형태를 갖고 있습니다.  
제가 주로 쓰는 Python,Objective-C의 Lambda와 비교해 봤습니다.

<pre>// Java 8
(int x, int y) -> { System.out.println(x+y); } 

// Objective-C
^(int x, int y){ NSLog(@"%d",x+y); }

// Python 2.x
// Python Lambda는 독특하게, Single Statement이어야 합니다. python 2.x에서 print는 function이 아닌 statement이기 때문에, print가 들어갈 수 없습니다. 따라서 python 3.x에서 print_function을 import해와야 합니다.
from __future__ import print_function
lambda x,y: print(x+y)
</pre>

JDK8에서는 Lambda와 더불어 기본 Lambda Type을 추가했습니다. 대표적으로 Predicate 예시를 보겠습니다.  
Predicate 는 @FunctionalInterface 로 test를 implements 하여야 합니다.  
List <person> 이 있고, 이들 중에 16살 이상인 사람의 이름을 출력해 보겠습니다. 

<pre class="lang:java decode:true " >Predicate&lt;Person&gt; overSixteen = p -&gt; p.getAge() &gt;= 16;

public void filter(List&lt;Person&gt; pl, Predicate&lt;Person&gt; pred){
    for (Person p:pl){
        if(pred.test(p)){
            System.out.println(p.getName());
        }
    }
}
filter(personList,overSixteen);</pre>

Lambda를 어떻게 활용하느냐는 전적으로 개발자의 몫이지만, 전체적으로 코드의 길이를 줄이고, 가독성을 높일 수 있을 것 같습니다. 

### 3. Stream API

Stream API 는 Iterator를 이용하여 루프를 돌면서 if문을 이용하여 필터를 하고, 목표한 행동을 하던 것을 멋지게 줄여줍니다. 좋은 예시가 있어서 가져와 봤습니다. [출처][3]

<pre class="lang:java decode:true ">List&lt;Block&gt; blocks = /* ... */;
 
int sumOfWeights = 0;
for (Block block : blocks) {
  if (block.getColor() == Color.RED) {
    sumOfWeights += block.getWeight();
  }
}</pre>

위 코드는 벽돌들 중 색이 빨간색인 벽돌들의 무게의 합을 구하는 코드입니다.  
Java 8의 StreamAPI를 이용하면 다음과 같이 작성할 수 있습니다. 

<pre class="lang:java decode:true " >List&lt;Block&gt; blocks = /* ... */;
int sumOfWeights = blocks.stream()
                      .filter(b -&gt; b.getColor() == Color.RED)
                      .map(b -&gt; b.getWeight())
                      .sum();</pre>

더불어 함께 추가된 기능은 parallelStream() 입니다. Fork/Join Framework을 이용하여 JVM의 멀티프로세싱을 통해 해당 코드를 알아서 병렬로 실행해 줍니다. 물론 Parallel 하게 실행하기 위한 Overhead가 있으므로, 항상 빠른 결과를 보장하지는 않습니다. 

## 4. JSR310 : Time and Date API Update

Java 의 Time과 Date API는 악명이 높습니다. 그래서 주로 외부 라이브러리를 많이 가져다 쓰는 것 같습니다. 이번 JDK8에서 이런 악명높은 Java의 Time,Date API를 싹 뜯어고쳤습니다.  
Joda Time Framework를 만드신 Stephane Coleburn 이 API Spec을 정리하였고, LocalDate, ZonedDateTime 등이 추가되었습니다. 시간관계상 많은 예시를 보지는 못했습니다. 

## 5. JSR308 : Type Annotation

Type Annotation 은 Java7의 Annotation에 이어 추가된 Annotation 입니다.  
대표적으로 @NotNull, @Nullable, @Readonly 등이 추가되었습니다.  
prefix Annotation으로, @NonNull Object @Nullable [] 은 Null인 오브젝트를 포함할 수도 있는 Null이 아닌 어레이 를 말합니다. 즉 어레이는 항상 존재하여야하지만, 어레이의 오브젝트는 Nullable인 것이지요. 

추가적으로, 같은 Annotation을 중복적용하는 것도 JDK8 이후로 허용됩니다.  
http://openjdk.java.net/jeps/120

## 6. JDK Convergence

JDK 8에서 Oracle의 Hotspot과 Oracle이 인수한 JRockit이 통합됩니다. 

## 7. Project Nashorn

Project Nashorn 은 JVM 상에서 JS를 실행하는 Project입니다. ECMAScript 5.1 spec을 기준으로 Java SE8과 ME8에 포함된다고 합니다. 

## 8. 기타

java.util.Map에 default Method들이 추가되었습니다. 

* * *이번 세미나를 통해 Oracle은 Java 9에 대한 로드맵도 일부 언급했습니다.

  
JDK 9에서는 JDK 8에 예정되었다가 미뤄진 Project Jigsaw : JDK Modular Platform 이 추가될 예정입니다. 현재 매우 큰 덩치를 갖고 있는 JDK를 필요한 부분만 모듈화 해서 로드한다는 것입니다.  
또한 Java 9에서는 Unified Type System으로 변경될 예정입니다. Premitive Type을 제거하고, int -> Integer와 같이 변화할 예정입니다.  
Project Sumatra : Java on GPUs 도 준비중입니다.  
더불어 Mobile이 매우 빠른 속도로 발전함에 따라 Java ME는 8버전이 마지막이 될 것 같습니다. 이제 Java SE9와 통합될 예정입니다. 모바일 AP들이 매우 빨라졌고, 심지어 메모리도 넉넉해진 마당에 굳이 ME를 따로 유지할 이유가 없어지기는 했습니다. </p> 

2014 제 14회 JCO의 첫번째 리뷰로 &#8220;Java 8 and Beyond&#8221;를 살펴보았습니다. 다음에는 두번째 리뷰로 &#8220;차세대 컴파일러, VM의 미래(부제 : 애플 오픈소스 프로젝트 LLVM)&#8221; 에 관해 정리해 보겠습니다.</person>

 [1]: https://bugs.openjdk.java.net/browse/JDK/fixforversion/11815
 [2]: http://zeroturnaround.com/rebellabs/java-8-explained-default-methods/
 [3]: http://blog.hartveld.com/2013/03/jdk-8-33-stream-api.html